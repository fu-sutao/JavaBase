# **ArrayList**

基于数组，具有动态扩展 如果不设置初始默认容量 则默认容量为10；

代表长度可变的数组。允许对元素进行快速的随机访问，但是向ArrayList中插入与删除元素的速度较慢。集合是可以往里面添东西的，用add(E e)方法往里面加（把E都看做Object）     

## 常用方法

 例子：ArrayList类中的add和get方法（add方法向集合中添加数据，get方法将集合中指定下标位置的数据取出）     （1）size()方法，返回集合中的元素个数，类似于数组中的length属性     

（2）clear()方法，将集合中的所有元素都给清除     

（3）isEmpty()方法判断集合是否为空，为空返回true     

（4）remove(int index)方法是删除集合中指定位置的元素，清除的原理是你清除了第一个后，后面的元素往前移，第一个变第0个了，原来第三个元素就没啦     （5）remove(Object ob)是remove的重载，一个是根据索引来删除，一个是根据具体对象来删除，比如remove("Hello");      （6）indexOf(Obejct ob)判断某个元素在索引的第几个位置上。在数组中查看数组元素个数，用数组的length属性，在集合中查看集合元素个数，用集合的size()方法。

## 注意事项

1）使用Iterator迭代集合过程中，不可修改集合元素，否则会引发异常。并且Iterator只能向后迭代 

（2）如果你想在循环过程中去掉某个元素,只能调用it.remove方法,   不能使用list.remove方法,   否则一定出并发访问的错误. 

 ArrayList扩容ensureCapacity的方案为“原始容量*3/2+1" 

 ArrayList是线程不安全的，在多线程的情况下不要使用。 

## Arraylist动态扩容原理

创建一个新的对象数组，容量为原来的1.5倍，把原来的对象数组中的对象数据复制到新的数组中

## Array遍历

```java
ArrayList<Test_JavaBean> arrayList = new ArrayList();
arrayList.add(new Test_JavaBean(11,23,"a","b"));
arrayList.add(new Test_JavaBean(32,32,"s","y"));
arrayList.add(new Test_JavaBean(15,24,"e","j"));
arrayList.add(new Test_JavaBean(13,62,"f","j"));
arrayList.add(new Test_JavaBean(61,27,"y","a"));
//for foreach循环遍历
for (Test_JavaBean test_javaBean : arrayList) {    System.out.println(test_javaBean.getId());
 }
//转化成数组
Test_JavaBean [] test_javaBeans = new Test_JavaBean[arrayList.size()];
test_javaBeans = arrayList.toArray(test_javaBeans);
//将arraylist转化成数组遍历
for(int i=0;i<test_javaBeans.length;i++){    System.out.println(test_javaBeans[i].getId());
 }
//使用迭代器
Iterator<Test_JavaBean> iterator = arrayList.iterator();
while (iterator.hasNext()){  
    System.out.println(iterator.next().getId());
}
```

# Vector

`vector`是array的线程安全版本，扩容方案为原来的2倍。可以自定义扩容方案

 <font color=#115282 size = 13>color=#00ffff</font> 

# LinkedList用法

LinkedList的链式线性表的特点为: 适合于在链表中间需要频繁进行插入和删除操作。

LinkedList的链式线性表的缺点为: 随机访问速度较慢。查找一个元素需要从头开始一个一个的找。速度你懂的。

LinkedList的内部是基于双向循环链表的结构来实现的

 LinkedList不是线程安全的 

# Set

Set接口区别于List接口的特点在于:

Set中的元素实现了不重复，有点象集合的概念，无序，不允许有重复的元素,最多允许有一个null元素对象。

需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是有由该元素的HashCode决定的，其具体位置其实是固定的。

此外需要说明一点，在set接口中的不重复是由特殊要求的。

  举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是

  如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到

  Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。

## HashSet

​     HashSet是Set接口的最常见的实现类了。其底层是基于Hash算法进行存储相关元素的。

你看到了什么，没错，对于HashSet的底层就是基于HashMap来实现的哦。

  我们都知道在HashMap中的key是不允许重复的，你换个角度看看，那不就是说Set集合吗？

  这里唯一一个需要处理的就是那个Map的value弄成一个固定值即可。

下面讲解一下HashSet使用和理解中容易出现的误区:

   a.HashSet中存放null值

​    HashSet中时允许出入null值的，但是在HashSet中仅仅能够存入一个null值哦。

   b.HashSet中存储元素的位置是固定的

​    HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，

​    所以HashSet中相应的元素的位置是固定的哦。

   c.遍历HashSet的几种方法

​     具体的方法不说了，请看下面的代码:

## LinkHashSet

​    LinkHashSet不仅是Set接口的子接口而且还是上面HashSet接口的子接口。

​    查看LinkedHashSet的部分源码如下:

## TreeSet

​    TreeSet是一种排序二叉树。存入Set集合中的值，会按照值的大小进行相关的排序操作。底层算法是基于红黑树来实现的。

​    TreeSet和HashSet的主要区别在于TreeSet中的元素会按照相关的值进行排序~

​    TreeSet和HashSet的区别和联系

​    \1. HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key
​    \2. Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能.
​    \3. hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可.
​      a. hashCode是用来计算hash值的,hash值是用来确定hash表索引的.
​      b. hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象
​       才可以真正定位到键值对应的Entry.
​      c. put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value
​    \4. 由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的.
​      a. Comparator可以在创建TreeMap时指定
​      b. 如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口.
​      c. TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了.

​     下面是一个使用TreeSet的实例:

# **3)Map接口**

   说到Map接口的话大家也许在熟悉不过了。Map接口实现的是一组Key-Value的键值对的组合。 Map中的每个成员方法由一个关键字（key）和一个值（value）构成。Map接口不直接继承于Collection接口（需要注意啦），因为它包装的是一组成对的“键-值”对象的集合，而且在Map接口的集合中也不能有重复的key出现，因为每个键只能与一个成员元素相对应。在我们的日常的开发项目中，我们无时无刻不在使用者Map接口及其实现类。Map有两种比较常用的实现：HashMap和TreeMap等。HashMap也用到了哈希码的算法，以便快速查找一个键，TreeMap则是对键按序存放，因此它便有一些扩展的方法，比如firstKey(),lastKey()等，你还可以从TreeMap中指定一个范围以取得其子Map。键和值的关联很简单，用pub(Object key,Object value)方法即可将一个键与一个值对象相关联。用get(Object key)可得到与此key对象所对应的值对象。

​    另外前边已经说明了，Set接口的底层是基于Map接口实现的。Set中存储的值，其实就是Map中的key，它们都是不允许重复的。

   Map接口的部分源码如下:

# 深入理解String

1. String s1=”1”;
2. String s2=new String(“1”);
   
   ![img](https://img-blog.csdn.net/20180827123540873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkwMDE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

从图中可以看出，s1使用””引号（也是平时所说的字面量）创建字符串，在编译期的时候就对常量池进行判断是否存在该字符串，如果存在则不创建直接返回对象的引用；如果不存在，则先在常量池中创建该字符串实例再返回实例的引用给s1。注意：编译期的常量池是静态常量池，以后和会讲。。。。

        再来看看s2，s2使用关键词new创建字符串，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中复制该对象的副本，然后将堆中对象的地址赋值给引用s2，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中复制该对象的副本，然后将堆中对象的地址赋值给引用s2。注意：此时是运行期，那么字符串常量池是在运行时常量池中的。。。。

[链接地址](https://blog.csdn.net/qq_34490018/article/details/82110578)

# [Hash算法的讲解](https://www.cnblogs.com/xiohao/p/4389672.html)

   散列表,又叫哈希表，它是基于**快速存取**的角度设计的，也是一种典型的“**空间换时间**”的做法。顾名思义，该数据结构可以理解为一个线性表，但是其中的元素不是紧密排列的，而是可能存在空隙。

   散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。比如我们存储70个元素，但我们可能为这70个元素申请了100个元素的空间。70/100=0.7，这个数字称为负载因子。我们之所以这样做，也 是为了“快速存取”的目的。我们基于一种结果尽可能随机平均分布的固定函数H为每个元素安排存储位置，这样就可以避免遍历性质的线性搜索，以达到快速存取。但是由于此随机性，也必然导致一个问题就是冲突。所谓冲突，即两个元素通过散列函数H得到的地址相同，那么这两个元素称为“同义词”。这类似于70个人去一个有100个椅子的饭店吃饭。散列函数的计算结果是一个存储单位地址，每个存储单位称为“桶”。设一个散列表有m个桶，则散列函数的值域应为[0,m-1]。    

   解决冲突是一个复杂问题。冲突主要取决于：

  （1）散列函数，一个好的散列函数的值应尽可能平均分布。

  （2）处理冲突方法。

  （3）负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。    

   解决冲突的办法：   

  （1）线性探查法：冲突后，线性向前试探，找到最近的一个空位置。缺点是会出现堆积现象。存取时，可能不是同义词的词也位于探查序列，影响效率。   

  （2）双散列函数法：在位置d冲突后，再次使用另一个散列函数产生一个与散列表桶容量m互质的数c，依次试探(d+n*c)%m，使探查序列跳跃式分布。

**常用的构造散列函数的方法**

　　散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：

　　**1. 直接寻址法：**取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数）

　　**2. 数字分析法：**分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相 同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会 明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。

　　**3. 平方取中法：**取关键字平方后的中间几位作为散列地址。

　　**4. 折叠法：**将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。

　　**5. 随机数法：**选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。

　　**6. 除留余数法：**取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。 **查找的性能分析**

　　散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按 处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平 均查找长度来衡量。

　　查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：

　　1. 散列函数是否均匀；

　　2. 处理冲突的方法；

　　3. 散列表的装填因子。

　　散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度

　　α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。

　　实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。

　　了解了hash基本定义，就不能不提到一些著名的hash算法，MD5 和 SHA-1 可以说是目前应用最广泛的Hash算法，而它们都是以 MD4 为基础设计的。那么他们都是什么意思呢?

　　这里简单说一下：

　　**（1) MD4**

　　MD4(RFC 1320)是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。它适用在32位字长的处理器上用高速软件实现--它是基于 32 位操作数的位操作来实现的。

　　**（2) MD5**

　　MD5(RFC 1321)是 Rivest 于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 相同。MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好

　　**（3) SHA-1 及其他**

　　SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1 设计时基于和MD4相同原理,并且模仿了该算法。

　　哈希表不可避免冲突(collision)现象：**对不同的关键字可能得到同一哈希地址** 即key1≠key2，而hash(key1)=hash(key2)。因此，在建造哈希表时不仅要设定一个好的哈希函数，而且要设定一种处理冲突的方法。可如下描述**哈希表**：根据设定的哈希**函数**H(key)和所选中的**处理冲突的方法**，将一组关键字映象到一个**有限的**、**地址连续**的地址集(区间)上并以**关键字在地址集中的“象”作为相应记录在表中的存储位置**，这种表被称为哈希表。

　　对于动态查找表而言，1) 表长不确定；2)在设计查找表时，只知道关键字所属范围，而不知道确切的关键字。因此，一般情况需建立一个函数关系，以f(key)作为关键字为key的 录在表中的位置，通常称这个函数f(key)为哈希函数。(注意：这个函数并不一定是数学函数)

　　哈希函数是一个映象，即：将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可。

　　现实中哈希函数是需要构造的，并且构造的好才能使用的好。

　　那么这些Hash算法到底有什么用呢?

　　Hash算法在信息安全方面的应用主要体现在以下的3个方面：

　　**（1) 文件校验**

　　我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，但却不能防止对数据的恶意破坏。

　　MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。

　　**（2) 数字签名**

　　Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。

　　**（3) 鉴权协议**

　　如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。

**文件hash值**

　　MD5-Hash-文件的数字文摘通过Hash函数计算得到。不管文件长度如何，它的Hash函数计算结果是一个固定长度的数字。与加密算法不 同，这一个Hash算法是一个不可逆的单向函数。采用安全性高的Hash算法，如MD5、SHA时，两个不同的文件几乎不可能得到相同的Hash结果。因 此，一旦文件被修改，就可检测出来。

   Hash函数还有另外的含义。实际中的Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。除此以外，Hash函数往往应用于查找上。所以，在考虑使用Hash函数之前，需要明白它的几个限制：
\1. Hash的主要原理就是把大范围映射到小范围；所以，你输入的实际值的个数必须和小范围相当或者比它更小。不然冲突就会很多。

\2. 由于Hash逼近单向函数；所以，你可以用它来对数据进行加密。

\3. 不同的应用对Hash函数有着不同的要求；比如，用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。 应用于加密的Hash函数已经探讨过太多了，在作者的博客里面有更详细的介绍。所以，本文只探讨用于查找的Hash函数。 Hash函数应用的主要对象是数组（比如，字符串），而其目标一般是一个int类型。

以下我们都按照这种方式来说明。 一般的说，Hash函数可以简单的划分为如下几类：

\1. 加法Hash； 2. 位运算Hash； 3. 乘法Hash； 4. 除法Hash； 5. 查表Hash； 6. 混合Hash；

下面详细的介绍以上各种方式在实际中的运用。

**一 加法Hash**

所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造如下：

```
`static` `int` `additiveHash(String key, ``int` `prime)` `{` `int` `hash, i;` `for` `(hash = key.length(), i = ``0``; i < key.length(); i++) ` `hash += key.charAt(i);` `return` `(hash % prime);` `}`
```

　　

这里的prime是任意的质数，看得出，结果的值域为[0,prime-1]。

**二 位运算Hash**

这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比如，标准的旋转Hash的构造如下：

```
`static` `int` `rotatingHash(String key, ``int` `prime) {` `int` `hash, i;` ` ``for` `(hash=key.length(), i=``0``; i  hash = (hash<<``4``>>``28``)^key.charAt(i);` `return` `(hash % prime);` `}`
```

　　

先移位，然后再进行各种位运算是这种类型Hash函数的主要特点。比如，以上的那段计算hash的代码还可以有如下几种变形：

```
`hash = (hash<<``5``>>``27``)^key.charAt(i);` ` ``hash += key.charAt(i);` `hash += (hash << ``10``);` `hash ^= (hash >> ``6``);` ` ``if``((i&``1``) == ``0``) {` `hash ^= (hash<<``7``>>``3``);` `} ``else` `{` `hash ^= ~((hash<<``11``>>``5``));` ` ``} hash += (hash<<``5``> hash = key.charAt(i) + (hash<<``6``>>``16``) ? hash; hash ^= ((hash<<``5``>>``2``));`
```

　　

**三 乘法Hash**

这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，

```
`static` `int` `bernstein(String key) {` `int` `hash = ``0``; ``int` `i;` `for` `(i=``0``; i ``return` `hash;` `}`
```

　　

jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。 使用这种方式的著名Hash函数还有：

```
`// 32位FNV算法 int M_SHIFT = 0; ` `public` `int` `FNVHash(``byte``[] data)  {   ` ` ``int` `hash = (``int``)2166136261L;   ` ` ``for``(``byte` `b : data)     ` `hash = (hash * ``16777619``) ^ b;   ` `if` `(M_SHIFT == ``0``)     ` `return` `hash;   ` ` ``return` `(hash ^ (hash >> M_SHIFT)) & M_MASK;` `}`
```

　　

以及改进的FNV算法：

```
`public` `static` `int` `FNVHash1(String data) {   ` ` ``final` `int` `p = ``16777619``;  ` `  ``int` `hash = (``int``)2166136261L;   ` ` ``for``(``int` `i=``0``;i     ` ` ``hash = (hash ^ data.charAt(i)) * p;   ` ` ``hash += hash << ``13``;   ` ` ``hash ^= hash >> ``7``;   ` ` ``hash += hash << ``3``;   ` ` ``hash ^= hash >> ``17``;   ` `hash += hash << ``5``;   ` `return` `hash;` `}`
```

　　

除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：

```
`static` `int` `RSHash(String str) {   ` `int` `b  = ``378551``;   ` `int` `a  = ``63689``;   ` ` ``int` `hash = ``0``;`` ``for``(``int` `i = ``0``; i < str.length(); i++) {   ` ` ``hash = hash * a + str.charAt(i);   ` ` ``a  = a * b;   }  ` ` ``return` `(hash & ``0x7FFFFFFF``);` `}`
```

　　

虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个了。关于它的介绍，大家可以去看RFC 1950规范。

**四 除法Hash**

除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”： hash = hash ^ (hash>>10) ^ (hash>>20)。

**五 查表Hash**

查表Hash最有名的例子莫过于CRC系列算法。虽然CRC系列算法本身并不是查表，但是，查表是它的一种最快的实现方式。下面是CRC32的实现：

static int crctab[256] = { 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d }; int crc32(String key, int hash) { int i; for (hash=key.length(), i=0; i  hash = (hash >> 8) ^ crctab[(hash & 0xff) ^ k.charAt(i)]; return hash; }

查表Hash中有名的例子有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。
**六 混合Hash**

混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用

作者：July、wuliming、pkuoliver

　　说明：本文分为三部分内容， 第一部分为一道百度面试题Top K算法的详解；第二部分为关于Hash表算法的详细阐述；第三部分为打造一个最快的Hash表算法。

　　**第一部分：Top K 算法详解**

　　问题描述（百度面试题）：

　　搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。

　　必备知识：

　　什么是哈希表？

　　哈希表（Hash table，也叫散列表），是根据key而直接进行访问的数据结构。也就是说，它通过把key映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

　　哈希表的做法其实很简单，就是把key通过一个固定的算法函数即所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。

  而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位**（**文章第二、三部分，会针对Hash表详细阐述**）**。

　　问题解析：

　　要统计最热门查询，首先就是要统计每个Query出现的次数，然后根据统计结果，找出Top 10。所以我们可以基于这个思路分两步来设计该算法。

　　即，此问题的解决分为以下两个步骤：

　　**第一步：Query统计**

　　Query统计有以下俩个方法，可供选择：

　　**1、直接排序法**

　　首先我们最先想到的的算法就是排序了，首先对这个日志里面的所有Query都进行排序，然后再遍历排好序的Query，统计每个Query出现的次数了。

　　但是题目中有明确要求，那就是内存不能超过1G，一千万条记录，每条记录是255Byte，很显然要占据2.375G内存，这个条件就不满足要求了。

　　让我们回忆一下数据结构课程上的内容，当数据量比较大而且内存无法装下的时候，我们可以采用外排序的方法来进行排序，这里我们可以采用归并排序，因为归并排序有一个比较好的时间复杂度O(nlogn)。

　　排完序之后我们再对已经有序的Query文件进行遍历，统计每个Query出现的次数，再次写入文件中。

　　综合分析一下，排序的时间复杂度是O(nlogn)，而遍历的时间复杂度是O(n)，因此该算法的总体时间复杂度就是O(n+nlogn)=O(nlogn)。

　　**2、Hash Table法**

　　在第1个方法中，我们采用了排序的办法来统计每个Query出现的次数，时间复杂度是O(nlogn)，那么能不能有更好的方法来存储，而时间复杂度更低呢？

　　题目中说明了，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query 255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择，因为Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。

　　那么，我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(n)的时间复杂度内完成了对该海量数据的处理。

　　本方法相比算法1：在时间复杂度上提高了一个数量级，为O(n)，但不仅仅是时间复杂度上的优化，该方法只需要IO数据文件一次，而算法1的IO次数较多的，因此该算法2比算法1在工程上有更好的可操作性。

　　**第二步：找出Top 10**

　　**算法一：普通排序**

  我想对于排序算法大家都已经不陌生了，这里不在赘述，我们要注意的是排序算法的时间复杂度是O(nlogn)，在本题目中，三百万条记录，用1G内存是可以存下的。

　　**算法二：部分排序**

　　题目要求是求出Top 10，因此我们没有必要对所有的Query都进行排序，我们只需要维护一个10个大小的数组，初始化放入10个Query，按照每个Query的统计次数由大到小排序，然后遍历这300万条记录，每读一条记录就和数组最后一个Query对比，如果小于这个Query，那么继续遍历，否则，将数组中最后一条数据淘汰，加入当前的Query。最后当所有的数据都遍历完毕之后，那么这个数组中的10个Query便是我们要找的Top10了。

　　不难分析出，这样，算法的最坏时间复杂度是N*K， 其中K是指top多少。

　　**算法三：堆**

　　在算法二中，我们已经将时间复杂度由NlogN优化到NK，不得不说这是一个比较大的改进了，可是有没有更好的办法呢？

　　分析一下，在算法二中，每次比较完成之后，需要的操作复杂度都是K，因为要把元素插入到一个线性表之中，而且采用的是顺序比较。这里我们注意一下，该数组是有序的，一次我们每次查找的时候可以采用二分的方法查找，这样操作的复杂度就降到了logK，可是，随之而来的问题就是数据移动，因为移动数据次数增多了。不过，这个算法还是比算法二有了改进。

　　基于以上的分析，我们想想，有没有一种既能快速查找，又能快速移动元素的数据结构呢？回答是肯定的，那就是堆。

　　借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此到这里，我们的算法可以改进为这样，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。

　　思想与上述算法二一致，只是算法在算法三，我们采用了最小堆这种数据结构代替数组，把查找目标元素的时间复杂度有O(K)降到了O(logK)。

　　那么这样，采用堆数据结构，算法三，最终的时间复杂度就降到了N‘logK，和算法二相比，又有了比较大的改进。 

　　**总结：**

　　至此，算法就完全结束了，经过上述第一步、先用Hash表统计每个Query出现的次数，O(N)；然后第二步、采用堆数据结构找出Top 10，N*O(logK)。所以，我们最终的时间复杂度是：**O(N)+N'\*O(logK)。**（N为1000万，N’为300万）。如果各位有什么更好的算法，欢迎留言评论。

　　**第二部分、Hash表算法的详细解析**

　　**什么是Hash**

　　Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

　　Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码，这些编码值叫做HASH值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。

　　数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：

![img](https://images0.cnblogs.com/news/1/201310/02093806-1251702e9b9f4036b037236bd8e6f847.jpg)

  左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。

　　元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：

　　**1，除法散列法** 

　　最直观的一种，上图使用的就是这种散列法，公式： 

   index = value % 16 

　　学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。

　　**2，平方散列法** 

　　求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式： 

   index = (value * value) >> 28  **（**右移，除以2^28。记法：左移变大，是乘。右移变小，是除。**）**

　　如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。

　　**3，斐波那契（Fibonacci）散列法**

　　平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。

　　1，对于16位整数而言，这个乘数是40503。

　　2，对于32位整数而言，这个乘数是2654435769。

　　3，对于64位整数而言，这个乘数是11400714819323198485。

　　这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,233, 377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。

　　对我们常见的32位整数而言，公式： 

　　index = (value * 2654435769) >> 28

　　如果用这种斐波那契散列法的话，那上面的图就变成这样了：

![img](https://images0.cnblogs.com/news/1/201310/02093807-bac8f5f1e31842db949471c48bb2f42b.jpg)

　　很明显，用斐波那契散列法调整之后要比原来的取摸散列法好很多。 

　　**适用范围**

　　快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。

　　**基本原理及要点**

　　hash函数选择，针对字符串、整数、排列，具体相应的hash方法。 

　　碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。

　　**扩展** 

　　d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。

　　**问题实例（海量数据处理）** 

　　我们知道hash 表在海量数据处理中有着广泛的应用，下面，请看另一道百度面试题：

　　题目：海量日志数据，提取出某日访问百度次数最多的那个IP。

　　方案：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将IP直接存入内存，然后进行统计。 

　　**第三部分、最快的Hash表算法**

　　接下来，咱们来具体分析一下一个最快的Hash表算法。

　　我们由一个简单的问题逐步入手：有一个庞大的字符串数组，然后给你一个单独的字符串，让你从这个数组中查找是否有这个字符串并找到它，你会怎么做？有一个方法最简单，老老实实从头查到尾，一个一个比较，直到找到为止，我想只要学过程序设计的人都能把这样一个程序作出来，但要是有程序员把这样的程序交给用户，我只能用无语来评价，或许它真的能工作，但...也只能如此了。

　　最合适的算法自然是使用HashTable（哈希表），先介绍介绍其中的基本知识，所谓Hash，一般是一个整数，通过某种算法，可以把一个字符串"压缩" 成一个整数。当然，无论如何，一个32位整数是无法对应回一个字符串的，但在程序中，两个字符串计算出的Hash值相等的可能非常小，下面看看在MPQ中的Hash算法：

　　**函数一、**以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
void prepareCryptTable()
{ 
    unsigned long seed = 0x00100001, index1 = 0, index2 = 0, i;
    for( index1 = 0; index1 < 0x100; index1++ )
    { 
        for( index2 = index1, i = 0; i < 5; i++, index2 += 0x100 )
        { 
            unsigned long temp1, temp2;
            seed = (seed * 125 + 3) % 0x2AAAAB;
            temp1 = (seed & 0xFFFF) << 0x10; 
            seed = (seed * 125 + 3) % 0x2AAAAB;
            temp2 = (seed & 0xFFFF); 
            cryptTable[index2] = ( temp1 | temp2 ); 
       } 
   }
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　**函数二、**以下函数计算lpszFileName字符串的hash值，其中dwHashType为hash的类型（在下面的函数三GetHashTablePos函数中调用此函数二），其可以取的值为0、1、2；该函数返回lpszFileName 字符串的hash值： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
unsigned long HashString( char *lpszFileName, unsigned long dwHashType )
{ 
    unsigned char *key  = (unsigned char *)lpszFileName;
    unsigned long seed1 = 0x7FED7FED;
    unsigned long seed2 = 0xEEEEEEEE;
    int ch;
    while(*key != 0)
    { 
        ch = toupper(*key++);
        seed1 = cryptTable[(dwHashType << 8) + ch] ^ (seed1 + seed2);
        seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3; 
    }
    return seed1; 
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　Blizzard的这个算法是非常高效的，被称为"One-Way Hash"（A one-way hash is a an algorithm that is constructed in such a way that deriving the original string (set of strings, actually) is virtually impossible）。举个例子，字符串"unitneutralacritter.grp"通过这个算法得到的结果是0xA26067F3。

　　是不是把第一个算法改进一下，改成逐个比较字符串的Hash值就可以了呢？答案是，远远不够。要想得到最快的算法，就不能进行逐个的比较，通常是构造一个哈希表(Hash Table)来解决问题。哈希表是一个大数组，这个数组的容量根据程序的要求来定义，例如1024，每一个Hash值通过取模运算 (mod) 对应到数组中的一个位置。这样，只要比较这个字符串的哈希值对应的位置有没有被占用，就可以得到最后的结果了，想想这是什么速度？是的，是最快的O(1)，现在仔细看看这个算法吧：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
typedef struct
{
    int nHashA;
    int nHashB;
    char bExists;
    ......
} SOMESTRUCTRUE;
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　一种可能的结构体定义？

　　**函数三、**下述函数为在Hash表中查找是否存在目标字符串，有则返回要查找字符串的Hash值，无则，return -1.

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
int GetHashTablePos( har *lpszString, SOMESTRUCTURE *lpTable ) 
//lpszString要在Hash表中查找的字符串，lpTable为存储字符串Hash值的Hash表。
{ 
    int nHash = HashString(lpszString);  //调用上述函数二，返回要查找字符串lpszString的Hash值。
    int nHashPos = nHash % nTableSize; 
    if ( lpTable[nHashPos].bExists  &&  !strcmp( lpTable[nHashPos].pString, lpszString ) ) 
    //如果找到的Hash值在表中存在，且要查找的字符串与表中对应位置的字符串相同
    {  
        return nHashPos;    //则返回上述调用函数二后，找到的Hash值
    } 
    else
    {
        return -1;  
    } 
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

  看到此，我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”，毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”，感谢大学里学的数据结构教会了这个百试百灵的法宝，我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。事情到此似乎有了完美的结局，如果是把问题独自交给我解决，此时我可能就要开始定义数据结构然后写代码了。

　　然而Blizzard的程序员使用的方法则是更精妙的方法。基本原理就是：他们在哈希表中不是用一个哈希值而是用三个哈希值来校验字符串。 

　　MPQ使用文件名哈希表来跟踪内部的所有文件。但是这个表的格式与正常的哈希表有一些不同。首先，它没有使用哈希作为下标，把实际的文件名存储在表中用于验证，实际上它根本就没有存储文件名。而是使用了3种不同的哈希：一个用于哈希表的下标，两个用于验证。这两个验证哈希替代了实际文件名。

　　当然了，这样仍然会出现2个不同的文件名哈希到3个同样的哈希。但是这种情况发生的概率平均是：1:18889465931478580854784，这个概率对于任何人来说应该都是足够小的。现在再回到数据结构上，Blizzard使用的哈希表没有使用链表，而采用"顺延"的方式来解决问题，看看这个算法：

　　**函数四、**lpszString为要在hash表中查找的字符串；lpTable为存储字符串hash值的hash表；nTableSize 为hash表的长度： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
int GetHashTablePos( char *lpszString, MPQHASHTABLE *lpTable, int nTableSize )
{
    const int  HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;
    int  nHash = HashString(lpszString, HASH_OFFSET);
    int  nHashA = HashString(lpszString, HASH_A);
    int  nHashB = HashString(lpszString, HASH_B);
    int  nHashStart = nHash % nTableSize;
    int  nHashPos = nHashStart; 
    while ( lpTable[nHashPos].bExists )
   {
     /* 如果仅仅是判断在该表中时候存在这个字符串，就比较这两个hash值就可以了，不用对结构体中的字符串进行比较。这样会加快运行的速度？减少hash表占用的空间？这种
方法一般应用在什么场合？*/
       if (lpTable[nHashPos].nHashA == nHashA
       &&  lpTable[nHashPos].nHashB == nHashB )
       {
            return nHashPos;
       }
       else
       {
            nHashPos = (nHashPos + 1) % nTableSize;
       }
        if (nHashPos == nHashStart) break;
    }
     return -1;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　上述程序解释：

　　1. 计算出字符串的三个哈希值（一个用来确定位置，另外两个用来校验)

　　2. 察看哈希表中的这个位置

　　3. 哈希表中这个位置为空吗？如果为空，则肯定该字符串不存在，返回-1。

　　4. 如果存在，则检查其他两个哈希值是否也匹配，如果匹配，则表示找到了该字符串，返回其Hash值。

　　5. 移到下一个位置，如果已经移到了表的末尾，则反绕到表的开始位置起继续查询　

　　6. 看看是不是又回到了原来的位置，如果是，则返回没找到

　　7. 回到3

　　ok，这就是本文中所说的最快的Hash表算法。什么?不够快?:D。欢迎，各位批评指正。

---

　　补充1、一个简单的hash函数：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/*key为一个字符串，nTableLength为哈希表的长度
*该函数得到的hash值分布比较均匀*/
unsigned long getHashIndex( const char *key, int nTableLength )
{
    unsigned long nHash = 0;
    while (*key)
    {
        nHash = (nHash<<5) + nHash + *key++;
    }
    return (nHash % nTableLength);
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　补充2、一个完整测试程序：  

　　哈希表的数组是定长的，如果太大，则浪费，如果太小，体现不出效率。合适的数组大小是哈希表的性能的关键。哈希表的尺寸最好是一个质数。当然，根据不同的数据量，会有不同的哈希表的大小。对于数据量时多时少的应用，最好的设计是使用动态可变尺寸的哈希表，那么如果你发现哈希表尺寸太小了，比如其中的元素是哈希表尺寸的2倍时，我们就需要扩大哈希表尺寸，一般是扩大一倍。 

  下面是哈希表尺寸大小的可能取值：

>    17,      37,     79,    163,     331, 
> 
>   673,      1361,    2729,    5471,     10949,    
> 
>   21911,     43853,   87719,   175447,   350899,
> 
>  701819,     1403641,  2807303,   5614657,   11229331,  
> 
>  22458671,    44917381,  89834777,  179669557,  359339171, 
> 
> 718678369,   1437356741, 2147483647

　　以下为该程序的完整源码，已在Linux下测试通过：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
#include <stdio.h>  
#include <ctype.h>     //多谢citylove指正。  
//crytTable[]里面保存的是HashString函数里面将会用到的一些数据，在prepareCryptTable  
//函数里面初始化  
unsigned long cryptTable[0x500];  
//以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]  
void prepareCryptTable()  
{   
    unsigned long seed = 0x00100001, index1 = 0, index2 = 0, i;  
    for( index1 = 0; index1 < 0x100; index1++ )  
    {   
        for( index2 = index1, i = 0; i < 5; i++, index2 += 0x100 )  
        {   
            unsigned long temp1, temp2;  
            seed = (seed * 125 + 3) % 0x2AAAAB;  
            temp1 = (seed & 0xFFFF) << 0x10;  
            seed = (seed * 125 + 3) % 0x2AAAAB;  
            temp2 = (seed & 0xFFFF);  
            cryptTable[index2] = ( temp1 | temp2 );   
       }   
   }   
}  
//以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，  
//在下面GetHashTablePos函数里面调用本函数，其可以取的值为0、1、2；该函数  
//返回lpszFileName 字符串的hash值；  
unsigned long HashString( char *lpszFileName, unsigned long dwHashType )  
{   
    unsigned char *key  = (unsigned char *)lpszFileName;  
unsigned long seed1 = 0x7FED7FED;  
unsigned long seed2 = 0xEEEEEEEE;  
    int ch;  
    while( *key != 0 )  
    {   
        ch = toupper(*key++);  
        seed1 = cryptTable[(dwHashType << 8) + ch] ^ (seed1 + seed2);  
        seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;   
    }  
    return seed1;   
}  
//在main中测试argv[1]的三个hash值：  
//./hash  "arr/units.dat"  
//./hash  "unit/neutral/acritter.grp"  
int main( int argc, char **argv )  
{  
    unsigned long ulHashValue;  
    int i = 0;  
    if ( argc != 2 )  
    {  
        printf("please input two arguments/n");  
        return -1;  
    }  
     /*初始化数组：crytTable[0x500]*/  
     prepareCryptTable();  
     /*打印数组crytTable[0x500]里面的值*/  
     for ( ; i < 0x500; i++ )  
     {  
         if ( i % 10 == 0 )  
         {  
             printf("/n");  
         }  
         printf("%-12X", cryptTable[i] );  
     }  
     ulHashValue = HashString( argv[1], 0 );  
     printf("/n----%X ----/n", ulHashValue );  
     ulHashValue = HashString( argv[1], 1 );  
     printf("----%X ----/n", ulHashValue );  
     ulHashValue = HashString( argv[1], 2 );  
     printf("----%X ----/n", ulHashValue );  
     return 0;  
}  
```

# 设计模式之单例模式

所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。

## **特点**

- 类构造器私有

- 持有自己类型的属性

- 对外提供获取实例的静态方法
  
  ## **懒汉模式**
  
  线程不安全，延迟初始化，严格意义上不是不是单例模式

```csharp
public class Singleton {  
    private static Singleton instance;  //创建字迹静态类型变量
    private Singleton (){}  //私有化构造 不让继承
  //创建获取自己实例的方法
    public static Singleton getInstance() {  
    if (instance == null) {  //判空
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```

**饿汉模式**
线程安全，比较常用，但容易产生垃圾，因为一开始就初始化

```cpp
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
```

**双重锁模式**
线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。

```java
public class Singleton {  
    private volatile static Singleton singleton; //当前实例静态化 
    private Singleton (){}  //构造器私有化不让重写
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于`singleton=new Singleton()`对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用`volatile`修饰`signleton`实例变量有效，解决该问题。

**静态内部类单例模式**

```java
public class Singleton { 
    private Singleton(){
    }
      public static Singleton getInstance(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
```

只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。
**枚举单例模式**

```swift
public enum Singleton {
    INSTANCE;
}
```

默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上

- 枚举类隐藏了私有的构造器。
- 枚举类的域 是相应类型的一个实例对象
  
  那么枚举类型日常用例是这样子的：

```csharp
public enum Singleton  {
    INSTANCE 

    //doSomething 该实例支持的行为

    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton get Instance() {
        return Singleton.INSTANCE;
    }
}
```

枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。
在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。
众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写`readResolve`方法，以让实例唯一。

```java
private Object readResolve() throws ObjectStreamException{
        return singleton;
}
```

Java高级特性——反射

[![img](https://upload.jianshu.io/users/upload_avatars/4272403/2681354b-0049-4aa6-a076-af1082e94363.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/2d3edce151d3)

[peter_RD_nj](https://www.jianshu.com/u/2d3edce151d3)关注

92018.08.27 16:40:42字数 1,009阅读 88,271

## 概述

## 定义

**[JAVA反射机制](https://baike.baidu.com/item/JAVA反射机制/6015990)是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。**

## 用途

在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。

## 反射机制的相关类

与Java反射相关的类如下：

| 类名           | 用途                         |
| ------------ | -------------------------- |
| Class类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| Field类       | 代表类的成员变量（成员变量也称为类的属性）      |
| Method类      | 代表类的方法                     |
| Constructor类 | 代表类的构造方法                   |

Class类

[Class](https://developer.android.google.cn/reference/java/lang/Class)代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。

- **获得类相关的方法**

| 方法                         | 用途                          |
| -------------------------- | --------------------------- |
| asSubclass(Class<U> clazz) | 把传递的类的对象转换成代表其子类的对象         |
| Cast                       | 把对象转换成代表类或是接口的对象            |
| getClassLoader()           | 获得类的加载器                     |
| getClasses()               | 返回一个数组，数组中包含该类中所有公共类和接口类的对象 |
| getDeclaredClasses()       | 返回一个数组，数组中包含该类中所有类和接口类的对象   |
| forName(String className)  | 根据类名返回类的对象                  |
| getName()                  | 获得类的完整路径名字                  |
| newInstance()              | 创建类的实例                      |
| getPackage()               | 获得类的包                       |
| getSimpleName()            | 获得类的名字                      |
| getSuperclass()            | 获得当前类继承的父类的名字               |
| getInterfaces()            | 获得当前类实现的类或是接口               |

- **获得类中属性相关的方法**

| 方法                            | 用途          |
| ----------------------------- | ----------- |
| getField(String name)         | 获得某个公有的属性对象 |
| getFields()                   | 获得所有公有的属性对象 |
| getDeclaredField(String name) | 获得某个属性对象    |
| getDeclaredFields()           | 获得所有属性对象    |

- **获得类中注解相关的方法**

| 方法                                              | 用途                  |
| ----------------------------------------------- | ------------------- |
| getAnnotation(Class<A> annotationClass)         | 返回该类中与参数类型匹配的公有注解对象 |
| getAnnotations()                                | 返回该类所有的公有注解对象       |
| getDeclaredAnnotation(Class<A> annotationClass) | 返回该类中与参数类型匹配的所有注解对象 |
| getDeclaredAnnotations()                        | 返回该类所有的注解对象         |

- **获得类中构造器相关的方法**

| 方法                                                 | 用途                  |
| -------------------------------------------------- | ------------------- |
| getConstructor(Class...<?> parameterTypes)         | 获得该类中与参数类型匹配的公有构造方法 |
| getConstructors()                                  | 获得该类的所有公有构造方法       |
| getDeclaredConstructor(Class...<?> parameterTypes) | 获得该类中与参数类型匹配的构造方法   |
| getDeclaredConstructors()                          | 获得该类所有构造方法          |

- **获得类中方法相关的方法**

| 方法                                                         | 用途          |
| ---------------------------------------------------------- | ----------- |
| getMethod(String name, Class...<?> parameterTypes)         | 获得该类某个公有的方法 |
| getMethods()                                               | 获得该类所有公有的方法 |
| getDeclaredMethod(String name, Class...<?> parameterTypes) | 获得该类某个方法    |
| getDeclaredMethods()                                       | 获得该类所有方法    |

- **类中其他重要的方法**

| 方法                                                               | 用途                 |
| ---------------------------------------------------------------- | ------------------ |
| isAnnotation()                                                   | 如果是注解类型则返回true     |
| isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果是指定类型注解类型则返回true |
| isAnonymousClass()                                               | 如果是匿名类则返回true      |
| isArray()                                                        | 如果是一个数组类则返回true    |
| isEnum()                                                         | 如果是枚举类则返回true      |
| isInstance(Object obj)                                           | 如果obj是该类的实例则返回true |
| isInterface()                                                    | 如果是接口类则返回true      |
| isLocalClass()                                                   | 如果是局部类则返回true      |
| isMemberClass()                                                  | 如果是内部类则返回true      |

## Field类

[Field](https://developer.android.google.cn/reference/java/lang/reflect/Field)代表类的成员变量（成员变量也称为类的属性）。

| 方法                            | 用途              |
| ----------------------------- | --------------- |
| equals(Object obj)            | 属性与obj相等则返回true |
| get(Object obj)               | 获得obj中对应的属性值    |
| set(Object obj, Object value) | 设置obj中对应属性值     |

## Method类

[Method](https://developer.android.google.cn/reference/java/lang/reflect/Method)代表类的方法。

| 方法                                 | 用途                      |
| ---------------------------------- | ----------------------- |
| invoke(Object obj, Object... args) | 传递object对象及参数调用该对象对应的方法 |

## Constructor类

[Constructor](https://developer.android.google.cn/reference/java/lang/reflect/Constructor)代表类的构造方法。

| 方法                              | 用途            |
| ------------------------------- | ------------- |
| newInstance(Object... initargs) | 根据传递的参数创建类的对象 |

## 示例

为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。

- **被反射类Book.java**

```tsx
public class Book{
    private final static String TAG = "BookTag";

    private String name;
    private String author;

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                '}';
    }

    public Book() {
    }

    private Book(String name, String author) {
        this.name = name;
        this.author = author;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    private String declaredMethod(int index) {
        String string = null;
        switch (index) {
            case 0:
                string = "I am declaredMethod 1 !";
                break;
            case 1:
                string = "I am declaredMethod 2 !";
                break;
            default:
                string = "I am declaredMethod 1 !";
        }

        return string;
    }
}
```

- **反射逻辑封装在ReflectClass.java**

```java
public class ReflectClass {
    private final static String TAG = "peter.log.ReflectClass";

    // 创建对象
    public static void reflectNewInstance() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Object objectBook = classBook.newInstance();
            Book book = (Book) objectBook;
            book.setName("Android进阶之光");
            book.setAuthor("刘望舒");
            Log.d(TAG,"reflectNewInstance book = " + book.toString());
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有的构造方法
    public static void reflectPrivateConstructor() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Constructor<?> declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class);
            declaredConstructorBook.setAccessible(true);
            Object objectBook = declaredConstructorBook.newInstance("Android开发艺术探索","任玉刚");
            Book book = (Book) objectBook;
            Log.d(TAG,"reflectPrivateConstructor book = " + book.toString());
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有属性
    public static void reflectPrivateField() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Object objectBook = classBook.newInstance();
            Field fieldTag = classBook.getDeclaredField("TAG");
            fieldTag.setAccessible(true);
            String tag = (String) fieldTag.get(objectBook);
            Log.d(TAG,"reflectPrivateField tag = " + tag);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有方法
    public static void reflectPrivateMethod() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Method methodBook = classBook.getDeclaredMethod("declaredMethod",int.class);
            methodBook.setAccessible(true);
            Object objectBook = classBook.newInstance();
            String string = (String) methodBook.invoke(objectBook,0);

            Log.d(TAG,"reflectPrivateMethod string = " + string);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 获得系统Zenmode值
    public static int getZenMode() {
        int zenMode = -1;
        try {
            Class<?> cServiceManager = Class.forName("android.os.ServiceManager");
            Method mGetService = cServiceManager.getMethod("getService", String.class);
            Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE);
            Class<?> cINotificationManagerStub = Class.forName("android.app.INotificationManager$Stub");
            Method mAsInterface = cINotificationManagerStub.getMethod("asInterface",IBinder.class);
            Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService);
            Method mGetZenMode = cINotificationManagerStub.getMethod("getZenMode");
            zenMode = (int) mGetZenMode.invoke(oINotificationManager);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return zenMode;
    }

    // 关闭手机
    public static void shutDown() {
        try {
            Class<?> cServiceManager = Class.forName("android.os.ServiceManager");
            Method mGetService = cServiceManager.getMethod("getService",String.class);
            Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE);
            Class<?> cIPowerManagerStub = Class.forName("android.os.IPowerManager$Stub");
            Method mShutdown = cIPowerManagerStub.getMethod("shutdown",boolean.class,String.class,boolean.class);
            Method mAsInterface = cIPowerManagerStub.getMethod("asInterface",IBinder.class);
            Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService);
            mShutdown.invoke(oIPowerManager,true,null,true);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) {
        try {
            Class<?> ServiceManager = Class.forName("android.os.ServiceManager");
            // 获得ServiceManager的getService方法
            Method getService = ServiceManager.getMethod("getService", java.lang.String.class);
            // 调用getService获取RemoteService
            Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE);
            // 获得IPowerManager.Stub类
            Class<?> cStub = Class.forName("android.os.IPowerManager$Stub");
            // 获得asInterface方法
            Method asInterface = cStub.getMethod("asInterface", android.os.IBinder.class);
            // 调用asInterface方法获取IPowerManager对象
            Object oIPowerManager = asInterface.invoke(null, oRemoteService);
            if (shutdown) {
                // 获得shutdown()方法
                Method shutdownMethod = oIPowerManager.getClass().getMethod(
                        "shutdown", boolean.class, String.class, boolean.class);
                // 调用shutdown()方法
                shutdownMethod.invoke(oIPowerManager, confirm, null, false);
            } else {
                // 获得reboot()方法
                Method rebootMethod = oIPowerManager.getClass().getMethod("reboot",
                        boolean.class, String.class, boolean.class);
                // 调用reboot()方法
                rebootMethod.invoke(oIPowerManager, confirm, null, false);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **调用相应反射逻辑方法**

```php
        try {
            // 创建对象
            ReflectClass.reflectNewInstance();

            // 反射私有的构造方法
            ReflectClass.reflectPrivateConstructor();

            // 反射私有属性
            ReflectClass.reflectPrivateField();

            // 反射私有方法
            ReflectClass.reflectPrivateMethod();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        Log.d(TAG," zenmode = " + ReflectClass.getZenMode());
```

Log输出结果如下：

```csharp
08-27 15:11:37.999 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book{name='Android进阶之光', author='刘望舒'}
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book{name='Android开发艺术探索', author='任玉刚'}
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod 1 !
08-27 15:11:38.004 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectDemo:  zenmode = 0
```

## 总结

本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。

在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。**带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。**其他的Annotation、Field、Constructor也是如此。

在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。**如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要浪费时间反射了。**

```bash
 W/System.err: java.lang.reflect.InvocationTargetException
 W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
 W/System.err:     at .ReflectClass.shutDown(ReflectClass.java:104)
 W/System.err:     at .MainActivity$1.onClick(MainActivity.java:25)
 W/System.err:     at android.view.View.performClick(View.java:6259)
 W/System.err:     at android.view.View$PerformClick.run(View.java:24732)
 W/System.err:     at android.os.Handler.handleCallback(Handler.java:789)
 W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:98)
 W/System.err:     at android.os.Looper.loop(Looper.java:164)
 W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6592)
 W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
 W/System.err:     at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
 W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:769)
 W/System.err: Caused by: java.lang.SecurityException: Neither user 10224 nor current process has android.permission.REBOOT.
 W/System.err:     at android.os.Parcel.readException(Parcel.java:1942)
 W/System.err:     at android.os.Parcel.readException(Parcel.java:1888)
 W/System.err:     at android.os.IPowerManager$Stub$Proxy.shutdown(IPowerManager.java:787)
 W/System.err:  ... 12 more
```

[ReflectDemo](https://gitee.com/peter_RD_nj/DemoAllInOne/tree/master/ReflectDemo)

参考文献

[认识反射机制（Reflection）](https://link.jianshu.com/?t=http://blog.qiji.tech/archives/4374)
[Java 反射机制](http://www.cnblogs.com/mengdd/archive/2013/01/26/2877972.html)
[一个例子让你了解Java反射机制](http://blog.csdn.net/ljphhj/article/details/12858767)
[Java反射机制的原理及在Android下的简单应用](https://link.jianshu.com/?t=http://www.cnblogs.com/crazypebble/archive/2011/04/13/2014582.html)
[java中的反射机制](https://link.jianshu.com/?t=http://zlb1986.iteye.com/blog/937781)
[Android注解与反射机制](https://link.jianshu.com/?t=http://efany.github.io/2016/04/02/Android注解与反射机制/)
[java.lang.reflect.Method](https://developer.android.google.cn/reference/java/lang/reflect/Method?hl=zh-cn)

# 末尾
